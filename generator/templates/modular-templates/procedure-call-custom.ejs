<% 
/* 
request Params - exists only if query params are not empty, otherwise it null
parameters - has parsed path params (name, otional, description, type)
*/
%>
<%
const { utils, route, config } = it;
const { requestBodyInfo, responseBodyInfo, specificArgNameResolver } = route;
const { _, getInlineParseContent, getParseContent, parseSchema, getComponentByRef, require } = utils;
const { parameters, path, method, payload, query, formData, security, requestParams, pathParams: pathParamsContentRaw } = route.request;
const { type, errorType, contentTypes } = route.response;
const { HTTP_CLIENT, RESERVED_REQ_PARAMS_ARG_NAMES } = config.constants;
const routeDocs = includeFile("./route-docs", { config, route, utils });
const queryName = (query && query.name) || "query";
const pathParams = _.values(parameters);
const pathParamsNames = _.map(pathParams, "name");

const isFetchTemplate = config.httpClientType === HTTP_CLIENT.FETCH;

const requestConfigParam = {
    name: specificArgNameResolver.resolve(RESERVED_REQ_PARAMS_ARG_NAMES),
    optional: true,
    type: "RequestParams",
    defaultValue: "{}",
}

console.log('>>> route.request: ', route.request)
console.log('>>> parameters:', parameters)
console.log('>>> requestParams:', requestParams)
console.log('>>> query:', query)
console.log('>>> formData: ', formData)

const argToTmpl = ({ name, optional, type, defaultValue }) => `${name}${!defaultValue && optional ? '?' : ''}: ${type}${defaultValue ? ` = ${defaultValue}` : ''}`;

const rawWrapperArgs = config.extractRequestParams ?
    _.compact([
        requestParams && {
          name: pathParams.length ? `{ ${_.join(pathParamsNames, ", ")}, ...${queryName} }` : queryName,
          optional: false,
          type: getInlineParseContent(requestParams),
        },
        ...(!requestParams ? pathParams : []),
        payload,
        requestConfigParam,
    ]) :
    _.compact([
        ...pathParams,
        query,
        payload,
        requestConfigParam, 
    ])

const wrapperArgs = _
    // Sort by optionality
    .sortBy(rawWrapperArgs, [o => o.optional])
    .map(argToTmpl)
    .join(', ')
    console.log('===================================')
    console.log('>>> contentTypes', contentTypes)
    console.log('>>> payload: ', payload, getParseContent(payload))
    console.log('>>> requestParams:', requestParams)
    console.log('>>> rawWrapperArgs: ', rawWrapperArgs)
    console.log('>>> getInlineParseContent(requestParams): ', getInlineParseContent(requestParams))
    console.log('>>> getParseContent(requestParams): ', getParseContent(requestParams))
    console.log('>>> wrapperArgs: ', wrapperArgs)
// RequestParams["type"]
const requestContentKind = {
    "JSON": "ContentType.Json",
    "URL_ENCODED": "ContentType.UrlEncoded",
    "FORM_DATA": "ContentType.FormData",
    "TEXT": "ContentType.Text",
}
// RequestParams["format"]
const responseContentKind = {
    "JSON": '"json"',
    "IMAGE": '"blob"',
    "FORM_DATA": isFetchTemplate ? '"formData"' : '"document"'
}

const bodyTmpl = _.get(payload, "name") || null;
const queryTmpl = (query != null && queryName) || null;
const bodyContentKindTmpl = requestContentKind[requestBodyInfo.contentKind] || null;
const responseFormatTmpl = responseContentKind[responseBodyInfo.success && responseBodyInfo.success.schema && responseBodyInfo.success.schema.contentKind] || null;
const securityTmpl = security ? 'true' : null;

const describeReturnType = () => {
    if (!config.toJS) return "";

    switch(config.httpClientType) {
        case HTTP_CLIENT.AXIOS: {
          return `Promise<AxiosResponse<${type}>>`
        }
        default: {
          return `Promise<HttpResponse<${type}, ${errorType}>`
        }
    }
}

%>
/*
 *
<%~ routeDocs.description %>

 *<% /* Here you can add some other JSDoc tags */ %><%~ config.extractRequestParams; JSON.stringify(rawWrapperArgs) %>

 * @author automated
 * @genereated <%~ route.routeName.usage %>
<%~ routeDocs.lines %>

 */
/*
export const <%~ route.routeName.usage %> = (<% //~ wrapperArgs %>)<%~ config.toJS ? `: ${describeReturnType()}` : "" %> =>
    <%~ config.singleHttpClient ? 'this.http.request' : 'this.request' %><<%~ type %>, <%~ errorType %>>({
        path: `<%~ path %>`,
        method: '<%~ _.upperCase(method) %>',
        <%~ queryTmpl ? `query: ${queryTmpl},` : '' %>
        <%~ bodyTmpl ? `body: ${bodyTmpl},` : '' %>
        <%~ securityTmpl ? `secure: ${securityTmpl},` : '' %>
        <%~ bodyContentKindTmpl ? `type: ${bodyContentKindTmpl},` : '' %>
        <%~ responseFormatTmpl ? `format: ${responseFormatTmpl},` : '' %>
        ...<%~ _.get(requestConfigParam, "name") %>,
    })
*/

<%
function getInputPathParamsContent(properties) {
    const inputPathRawArgs = Object.fromEntries(Object.entries(properties).filter(([key, value]) => value.in === 'path'))
    const inputPathRawNames = Object.values(inputPathRawArgs).map(({name}) => name)
    const content = getParseContent({properties: inputPathRawArgs}).replaceAll(',', '')
    return content
}

const inputPathParamsContent = getInputPathParamsContent(requestParams.properties) 
const inputPathNamesContent =parameters.map(({name}) => name).join(', ')
console.log('>>> p4')
const inputQueryRawArgs = Object.fromEntries(Object.entries(requestParams.properties).filter(([key, value]) => value.in === 'query'))
console.log('>>> inputQueryRawArgs: ', inputQueryRawArgs)
const inputQueryContent = getParseContent({properties: inputQueryRawArgs}).replaceAll(',', '')

console.log('>>> getParseContent:inputRawArgs:',inputPathParamsContent)
console.log('>>> route.routeName:', route.routeName)
console.log('>>> inputQueryContent: ', inputQueryContent)
const routeNameUppper = route.routeName.usage.charAt(0).toUpperCase() + route.routeName.usage.slice(1)
const inputPathInterface = `Input${routeNameUppper}`
const searchParamsInterface = `SearchParams${routeNameUppper}`
const inputClientTypeName = `${routeNameUppper}Input`
const outputClientTypeName = `${routeNameUppper}Output`
%>

interface <%~ inputPathInterface %> <%~ payload ? `extends ${payload.type}` : '' %> {
    <%~ inputPathParamsContent %>
}


interface <%~ searchParamsInterface %> {
    <%~ inputQueryContent %>
}

type <%~ inputClientTypeName %> = BaseInput & {}
type <%~ outputClientTypeName %> = BaseOutput<<%~ type %>>

/*
 *
<%~ routeDocs.description %>

 *<% /* Here you can add some other JSDoc tags */ %><%~ config.extractRequestParams; JSON.stringify(rawWrapperArgs) %>

 * @author automated
 * @genereated <%~ route.routeName.usage %>
<%~ routeDocs.lines %>

 */
export const <%~ route.routeName.usage %> = (input: <%~ inputPathInterface%>, searchParams: <%~ searchParamsInterface %> ) => {
    const { <%~ inputPathNamesContent %>, ...body} = input

    return new AxiosRestClient<<%~ inputClientTypeName %>, <%~ outputClientTypeName %>>({
        resourcePath: `<%~ path %>`
    }).execute({
        method: '<%~ _.upperCase(method) %>',
        body,
        headers: new Headers({
            // TODO: add appropriate headers
        }),
        searchParams,
    });
};